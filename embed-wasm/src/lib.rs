use headers::HeaderMapExt;
use hyper::{Body, Response};


#[derive(PartialEq, Eq)]
pub enum IndexHandling {
    MapEmptyPathToIndex,
    NoIndexHandling,
}

pub struct StaticLookup {
    pub index_mode: IndexHandling,
    pub wasm: &'static phf::Map<&'static str, &'static [u8]>,
}

impl StaticLookup {
    // path expected as `let x: http::uri::PathAndQuery = ..; x.as_str()`, omiting type to simplify interface
    pub fn get(&self, path: &str) -> Option<Response<Body>> {
        // drop leading '/' from path
        let path = &path[1..];

        let path = if path.len() == 0 && self.index_mode == IndexHandling::MapEmptyPathToIndex {
            "index.html"
        } else {
            path
        };

        match self.wasm.get(path).map(|p| *p) {
            None => None,
            Some(blob) => {
                let body = hyper::Body::from(blob);
                let mut resp = hyper::Response::new(body);

                let mime_type = mime_guess::from_path(path).first_or_octet_stream();
                resp.headers_mut()
                    .typed_insert(headers::ContentType::from(mime_type));
                resp.headers_mut()
                    .typed_insert(headers::AcceptRanges::bytes());
                resp.headers_mut()
                    .typed_insert(headers::ContentLength(blob.len() as u64));

                Some(resp)
            }
        }
    }
}

/// Imports the generated static wasm blobs from the build output directory as
/// generated by embed_wasm_build::compile_wasm
#[macro_export]
macro_rules! include_wasm {
    () => {
        include!(concat!(env!("OUT_DIR"), "/wasm_blobs.rs"));

        // FIXME: will fail if user aliases embed_wasm
        pub static STATIC_LOOKUP: ::embed_wasm::StaticLookup  =
            ::embed_wasm::StaticLookup{
                index_mode: ::embed_wasm::IndexHandling::MapEmptyPathToIndex,
                wasm: &WASM,
        };
    };
}
